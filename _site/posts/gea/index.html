<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.39">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2025-07-25">
<meta name="description" content="where we are and how to move forward">

<title>engineered-DNA forensics</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
.display.math{display: block; text-align: center; margin: 0.5rem auto;}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../favicon.png" rel="icon" type="image/png">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-e8fb9d25728d58bfeac61b497e4a6629.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-55a5241d4fbd08b1b19b2c60d0ad10c9.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script src="../../site_libs/quarto-contrib/nutshell-1.0.7/nutshell.js"></script>
<script src="../../site_libs/quarto-contrib/nutshell-1.0.7/nutshell_options.js"></script>
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-FYLF41PFGT"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-FYLF41PFGT', { 'anonymize_ip': true});
</script>
<script src="../../site_libs/quarto-diagram/mermaid.min.js"></script>
<script src="../../site_libs/quarto-diagram/mermaid-init.js"></script>
<link href="../../site_libs/quarto-diagram/mermaid.css" rel="stylesheet">
<meta name="quarto:status" content="draft">


</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top"><div id="quarto-draft-alert" class="alert alert-warning"><i class="bi bi-pencil-square"></i>Draft</div>
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../../favicon.png" alt="" class="navbar-logo">
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">blog</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">about</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../projects.html"> 
<span class="menu-text">projects</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">engineered-DNA forensics</h1>
  <div class="quarto-categories">
    <div class="quarto-category">biosecurity</div>
  </div>
  </div>

<div>
  <div class="description">
    where we are and how to move forward
  </div>
</div>


<div class="quarto-title-meta">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">July 25, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<p>Engineered organisms (&gt;bio-agents) are created in labs around the world. Lab-leaks are relatively common even in <a href="#x-bsl4">:BSL-4</a> labs. Bad actors, including nation states and terror groups have always had a large <a href="../../posts/dacc-bio/index.html">interest in bioweapons</a>. However, once a bio-agent is out in the wild, it’s really difficult to figure out <em>who</em> developed it in the first place.</p>
<p>The problem is called <strong>genetic engineering attribution (GEA)</strong>. The challenge of GEA is tracing back <em>engineered</em> organisms to their designers through signatures in their DNA.</p>
<p>But why could that work? There’s many degrees of freedom in genetic engineering, and the combination of design, style and tools used creates a unique DNA pattern in the synthetic organism, sometimes leading straight to its lab-of-origin.</p>
<p>GEA is a key defensive technology. Once mature, it will allow us to quickly respond to outbreaks, identify responsible labs to fill safety gaps and, importantly, deter bad actors. It’s something we should invest in.</p>
<p>While the field itself arguably started with the microbial forensics investigations of <a href="https://www.tandfonline.com/doi/full/10.1080/00396331003612521">Amerithrax</a>, GEA back then was manual, specific and slow. In the machine learning era, we’re able to develop general tools that work for a wide range of bio-agents and labs. But how far are we?</p>
<section id="raw-nucleotides-cnn" class="level3">
<h3 class="anchored" data-anchor-id="raw-nucleotides-cnn">2018: raw nucleotides + CNN</h3>
<p><a href="https://www.nature.com/articles/s41467-018-05378-z">Nielsen &amp; Voigt, 2018</a> is the first study using machine learning for GEA. They used engineered <a href="#x-plasmid">:Plasmid</a> sequences from <a href="https://www.addgene.org/">Addgene</a>, an open source database. It’s one of the few databases where each engineered sequence is linked to the lab that designed it.</p>
<p>Their data contained 36,764 plasmid sequences from 827 labs. To make the sequences available to model, they simply <a href="#x-one-hot">:one-hot encoded</a> each nucleotide, resulting in a 16,048 x 4 matrix of for each plasmid sequence. Then, they trained a simple CNN to predict which of the labs the sequence came from.</p>
<div class="cell" data-layout-align="default">
<div class="cell-output-display">
<div id="fig-cnn" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-cnn-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div>
<pre class="mermaid mermaid-js" data-label="fig-cnn">flowchart LR
    A["DNA Sequence&lt;br/&gt;A T G C&lt;br/&gt;1 0 0 0&lt;br/&gt;0 1 0 0&lt;br/&gt;0 0 1 0&lt;br/&gt;0 0 0 1&lt;br/&gt;...&lt;br/&gt;16,048 × 4"] --&gt; B["Conv&lt;br/&gt;+&lt;br/&gt;MaxPool"] --&gt; C["Fully&lt;br/&gt;Connected"] --&gt; D["827 labs&lt;br/&gt;Softmax"]
    
    style A fill:#e3f2fd,stroke:#1976d2,stroke-width:3px
    style B fill:#fff3e0,stroke:#f57c00,stroke-width:3px
    style C fill:#e8f5e8,stroke:#388e3c,stroke-width:3px
    style D fill:#fce4ec,stroke:#c2185b,stroke-width:3px
</pre>
</div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-cnn-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1: Nielsen &amp; Voigt CNN Architecture for Lab-of-Origin Prediction
</figcaption>
</figure>
</div>
</div>
</div>
<p>The CNN correctly predicted the lab-of-origin in 48% of held-out sequences, and 70% of the time the correct lab was in the top 10 predictions. This isn’t quite good enough to apply to a real case, but they made a point: There actually <em>is</em> a unique lab-of-origin signature in these sequences. ML-GEA is up to a promising start.</p>
</section>
<section id="base-pair-encoding-lstm" class="level3">
<h3 class="anchored" data-anchor-id="base-pair-encoding-lstm">2020: base-pair encoding + LSTM</h3>
<p><a href="https://www.nature.com/articles/s41467-020-19612-0">Alley et al, 2020</a> are next in line. They also used plasmid data from Addgene. After preprocessing, they had a dataset of over 80,000 sequences from over 1,300 labs, substantially larger than Nielsen &amp; Voigt two years before.</p>
<p>Instead of directly training a model on nucleotides, they used <a href="#x-bpe">:byte-pair encoding (BPE)</a> to identify reccuring patterns in the DNA, called motifs. These motifs mapped to codons, regulatory and conserved regions. Each motif then became a token that is fed to the model.</p>
<p>In addition to DNA, they also trained their model based on six phenotypes such as growth temperature and antibiotic resistance. In a real world scenario, this means that we would have to sequence the sample and run lab tests to get these phenotypes.</p>
<p>To predict the lab-of-origin from sequences and phenotypes, they used an <a href="#x-lstm">:LSTM</a> trained in a two step process. First, they trained on sequences only, and then added phenotypes and finetuned the model. This training strategy prevented the model to get stuck in a local minimum caused by the phenotype data early in training.</p>
<div class="cell" data-layout-align="default">
<div class="cell-output-display">
<div id="fig-lstm" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-lstm-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div>
<pre class="mermaid mermaid-js" data-label="fig-lstm">flowchart LR
    A["DNA Sequence&lt;br/&gt;ATGCGTAA...&lt;br/&gt;↓&lt;br/&gt;BPE Motifs"] --&gt; B["LSTM"] --&gt; C["Metadata&lt;br/&gt;+&lt;br/&gt;Concat"] --&gt; D["1314 labs&lt;br/&gt;Softmax"]
    
    style A fill:#e3f2fd,stroke:#1976d2,stroke-width:3px
    style B fill:#fff3e0,stroke:#f57c00,stroke-width:3px
    style C fill:#e8f5e8,stroke:#388e3c,stroke-width:3px
    style D fill:#fce4ec,stroke:#c2185b,stroke-width:3px
</pre>
</div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-lstm-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2: Alley et al.&nbsp;deteRNNt architecture for Lab-of-Origin Prediction
</figcaption>
</figure>
</div>
</div>
</div>
<p>The sequence+phenotype LSTM predicted the correct lab-of-origin 70% of the time, with a 84% top-10 accuracy. This is better than before, but it’s unclear whether the performance increase comes from LSTM vs.&nbsp;CNN, BPE vs raw nucleotide encoding, more sequence data or the addition of meta-data to the training.</p>
<p>The authors also show that the model is well <a href="#x-calibration">:calibrated</a> and that a simpler random forest model can predict the nation-of-origin with 88% top-3 accuracy compared to 47% for simply guessing the most abundant nations in the database.</p>
</section>
<section id="pangenome-alignment-no-deep-learning" class="level3">
<h3 class="anchored" data-anchor-id="pangenome-alignment-no-deep-learning">2022: pangenome + alignment (no deep learning!)</h3>
<p>Do we actually need deep learning at all? <a href="https://www.nature.com/articles/s41467-021-21180-w">Wang et al., 2022</a> don’t think so. They developed PlasmidHawk, which uses a much simpler approach based on a <a href="#x-pan">:pangenome</a>, sequence alignment and fragment counting. This is how it works:</p>
<p><em>Setup</em></p>
<ol type="1">
<li>create a pangenome from ALL plasmid sequences<br>
</li>
<li>align each plasmid sequence back to the pangenome to annote <em>each fragment or sub-sequence</em> with lab-of-origin information. These are not unique, some fragments will be annotated with multiple labs.</li>
</ol>
<p><em>Prediction</em></p>
<ol start="3" type="1">
<li>take a new plasmid sequence and align to the pangenome<br>
</li>
<li>count how often each lab occurs among the aligned fragments. This is a raw score already. One of the labs will occur most often, making it a good candidate for the lab-of-origin.</li>
<li>but they calculate a lab score - a more elegant, <em>weighted</em> version of the raw count. The idea is: the fewer labs share a fragment, the more indicative it is for labs that that have it.</li>
</ol>
<div class="cell" data-layout-align="default">
<div class="cell-output-display">
<div id="fig-plasmidHawk" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-plasmidHawk-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div>
<pre class="mermaid mermaid-js" data-label="fig-plasmidHawk">flowchart LR
    subgraph S1 ["Setup Phase"]
        E["Addgene&lt;br/&gt;Repository"] 
        F["Build&lt;br/&gt;Pan-genome"] 
        G["Annotate&lt;br/&gt;Lab Origins"]
        E --&gt; F --&gt; G
    end
    
    subgraph S2 ["Prediction Phase"]
        A["Unknown&lt;br/&gt;Plasmid"] 
        B["Align to&lt;br/&gt;Pan-genome"] 
        C["Count&lt;br/&gt;Fragments"] 
        D["Predict&lt;br/&gt;Lab Origin"]
        A --&gt; B --&gt; C --&gt; D
    end
    
    G -.-&gt; B
    
    style S1 fill:none,stroke:none
    style S2 fill:none,stroke:none
    style E fill:#f3e5f5,stroke:#7b1fa2,stroke-width:4px,color:
    style F fill:#fff9c4,stroke:#f9a825,stroke-width:4px,color:
    style G fill:#fff9c4,stroke:#f9a825,stroke-width:4px,color:
    style A fill:#e3f2fd,stroke:#1976d2,stroke-width:4px,color:
    style B fill:#fff3e0,stroke:#f57c00,stroke-width:4px,color:
    style C fill:#e8f5e8,stroke:#388e3c,stroke-width:4px,color:
    style D fill:#fce4ec,stroke:#c2185b,stroke-width:4px,color:
</pre>
</div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-plasmidHawk-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3: Wang et al.&nbsp;PlasmidHawk Pipeline for Lab-of-Origin Prediction
</figcaption>
</figure>
</div>
</div>
</div>
<p>Their method, called PlasmidHawk, had a 76% accuracy for lab-of-origin prediction and a 85% top-10 accuracy, which is better than the two neural network models before. They say it’s more efficient than deep learning too, as updating the pangenome with new plasmids is quick compared to re-training a neural network, but the data isn’t that big and DL hardware/software is becoming very efficient, so I believe this isn’t a substantial point anymore.</p>
<p>A big advantage of this approach is interpretability. For each novel sequence, the method directly surfaces the association between fragment and lab-of-origin after aligning it to the pangenome. This leaves a few more degrees of freedom though: The size of fragments has to be chosen manually, and so does the similarity threshold for alignment. The method also doesn’t allow to incorporate additional meta-data like the LSTM approach above, which will be crucial in real-word GEA.</p>
</section>
<section id="gea-competition" class="level3">
<h3 class="anchored" data-anchor-id="gea-competition">2022: GEA competition</h3>
<p>The first <a href="https://www.nature.com/articles/s41467-022-35032-8">GEA competition</a> had 1,200 competitors. They worked with the Alley at al data: 81,833 plasmid sequences + meta-data and 1314 labs-of-origin to predict. There are many more labs in the Addgene database, but all labs with fewer than ten plasmids were pooled into an “Unknown Engineered” category.</p>
<p>The top-teams’ models vastly outperformed previous models, with a top-1 accuracy of 82% and a top-10 accuracy of 95%.</p>
<p>They were also much better at <em>negative</em> attribution - the ability to <em>exclude</em> potential designers. This is measured by ab X99 score. X99 is the minimum positive integer N, so that the top-N accuracy is at least 99%. For example, X99 would be 279 if the lab-of-origin would be among the top 279 predicted candidates 99% of the time. In Nilsen &amp; Voigt 2018, the X99 was 898, the winning model in the competition had a score of 299.</p>
<p>So what were the modeling strategies of the winners? Mostly <a href="#x-ensemble">:ensembles</a> containing CNNs, though the details (pre-processing etc) varied substantially.</p>
<p><em>Problems</em></p>
<p><a href="https://www.nature.com/articles/s41467-022-35032-8">Crook et al 2022</a> describe some of the issues they observed in the competition models:</p>
<ul>
<li>low <a href="#x-calibration">:calibration</a> scores, except for the winning model</li>
<li>problematic large composite “Unknown Engineered” class, in which all labs with fewer than 10 sequences (~2000 labs) are pooled. The top-10 accuracy for the Unknown Engineered class was consistently very high, inflating the overall prediction, thought the problem didn’t seem to be very big for the best models.</li>
</ul>
<p><em>Deeper dive into a top solution</em></p>
<p><a href="https://www.nature.com/articles/s43588-022-00234-z">Soares et al</a> published their solution, which was one of the winners. Their model had a 90% top-10 accuracy.</p>
<p>Their initial model was a CNN with two tweaks. First, they also used <a href="#x-bpe">:BPE</a>. Second, they used circular shift augmentation. The key insight here is that plasmid DNA is circular, it doesn’t have a start or an end. The sequence <code>ATGCACTAG</code> shifted by 3 is <code>CACTAGATG</code>. To reflect this, they randomly shift sequences during training, which helps the model to learn local motifs and relative nucleotide arrangements rather than absolute positions, and increases the training set. This model was already better than all pre-competition models, with a 76% top-1 and 89% top-10 accuracy.</p>
<p>But the interesting bit is their second model. Here, the base-model is the same CNN as before, but instead of a final softmax layer that directly predicts the lab, they used a <strong>triplet network</strong>.</p>
<p>The idea of a triplet network is this: for each training example, we create a triplet consisting of a plasmid sequence (the anchor), its true lab-of-origin (the positive) and a different lab (the negative). The CNN processes the sequence and the labs into 200-D learnable <a href="#x-embed">:embedding</a> vectors.</p>
<p>During training, the model learns to poisition the anchor embedding vector closer to the positive lab embedding than to the negative one, using a triplet loss function. Instead of predicting lab-classes, they create embedding vectors. These can then be used to still predict classes, simply by measuring the distance of a sequence embedding to the nearest labs. The closest lab embedding is the top-1 candidate.</p>
<p>Now, while the model was only ever so slightly better than the simpler CNN, it comes with other advantages:</p>
<ul>
<li>interpretability: We can visualise the embeddings easily</li>
<li>few-shot learning: Even with a single sequence from a new model we can ask which lab embeddings are closest</li>
<li>dimensional &gt; categorical: instead of assigning a single class, we get distances in space, which can tell a more nuanced story</li>
</ul>
</section>
<section id="summary---where-are-we" class="level2">
<h2 class="anchored" data-anchor-id="summary---where-are-we">summary - where are we</h2>
<p>GEA is in its infancy. Every single study so far has built models to predict the lab-of-origin from plasmid sequences in the Addgene database.</p>
<p>This is largely a pragmatic choice. Addgene contains lots of curated sequences with associated meta-data and lab-of-origin. Studies so far have shown that GEA is <em>possible</em>, and that models can predict the lab-of-origin with accuracies of ~70-80%, decent negative attribution and good calibration.</p>
<p>But most models probably won’t be useful in the case of a real outbreak, because:</p>
<p><strong>Many bio-agents won’t have a plasmid</strong></p>
<p>A bio-agent might not have a plasmid at all. Most viruses don’t have plasmids and even engineered bacteria may not have an engineered plasmid if the engineered trait has been chromosomally integrated.</p>
<p><strong>Models are less likely to predict bad actors</strong></p>
<p>Terror organisations won’t deposit sequences in Addgene, and neither will the labs they are associated with. Models so far are therefore best at predicting trustworthy labs that care about transparency and data sharing. This is still useful for tracing accidental outbreaks though.</p>
<p><strong>Open-source might be a problem</strong></p>
<p>All models so far are trained on open-source data, allowing bad actors to create plasmid sequences mimicking other labs. This will leave it’s own traces, but is worth thinking about. AI-designers could help to further cover tracks, though other AIs could be trained to spot this.</p>
</section>
<section id="how-to-move-forward" class="level2">
<h2 class="anchored" data-anchor-id="how-to-move-forward">how to move forward</h2>
<p>Let’s think through a step-by-step approach to make GEA a mature field.</p>
<ol type="1">
<li><p><strong>data</strong>: We want GEA to handle <em>any</em> sequence, from whole-genomes to viruses, from plasmids to <a href="#x-synth">:synthetic assemblies</a>. Therefore, we need to create comprehensive databases linking these to lab-of-origin and meta-data.</p></li>
<li><p><strong>models</strong>: Most models so far are highly specific in their hyperparameter optimisation, data-preprocessing and ensembling. To handle any sequence, we need highly flexible models that are trained across the biosec-relevant part of the tree-of-life and can handle any sequence length. Sequence foundation models in the style of <a href="https://arcinstitute.org/tools/evo">evo2</a> might be able to do this.</p></li>
<li><p><strong>integration into a wider framework</strong>. Technical GEA is only part of the solution. We’ll also have non-technical information (location, epidemiological features etc.) of outbreaks as well as intelligence (whistleblowers, surveillance). We need to integrate them into a coherent framework.</p></li>
<li><p><strong>genetic attribution security</strong>. Once GEA is mature enough, there will be new problems, such as AI-assisted evasion of lab-of-origin detection. At this point we’ll need defensive systems that are robust to obfuscation and stay on top in a new adversarial arms race between GEA tools and evasion techniques.</p></li>
</ol>
</section>
<section id="x-plasmid" class="level2">
<h2 class="anchored" data-anchor-id="x-plasmid">:x plasmid</h2>
<p>Plasmids are small, circular pieces of DNA that float around outside the actual genome. They are a good vector to transport genes into the cell, are relatively easy to work with and self-replicating. That’s why they are often used for genetic engineering.</p>
</section>
<section id="x-bpe" class="level2">
<h2 class="anchored" data-anchor-id="x-bpe">:x bpe</h2>
<p>Byte-pair encoding (BPE) is a tokenization method that breaks down DNA sequences into meaningful subunits rather than individual nucleotides. Instead of treating each A, T, G, C separately, BPE identifies frequently occurring pairs and merges them into single tokens, creating a more efficient representation. They also allow inputs to be of different lenghts, which is very useful for DNA sequences.</p>
</section>
<section id="x-lstm" class="level2">
<h2 class="anchored" data-anchor-id="x-lstm">:x lstm</h2>
<p>Long Short-Term Memory (LSTM) is a type of neural network designed to remember information over long sequences. Unlike regular neural networks that forget previous inputs, LSTMs have special “gates” that control what information to keep, forget, or output. They also take input of different lengths, which is great for DNA sequences.</p>
</section>
<section id="x-pan" class="level2">
<h2 class="anchored" data-anchor-id="x-pan">:x pan</h2>
<p>Traditionally, genomics has worked with a single reference genome against which samples are aligned. This approach loses variation - if a sample has genetic features that can’t be aligned to the reference, they’re discarded. A pangenome captures all genetic variation across multiple samples in a single data structure, often represented as a graph rather than a linear sequence.</p>
</section>
<section id="x-ensemble" class="level2">
<h2 class="anchored" data-anchor-id="x-ensemble">:x ensemble</h2>
<p>Ensemble methods do as they sound: They combine the predictions of multiple different models, often leading to more accurate and reliable results.</p>
</section>
<section id="x-calibration" class="level2">
<h2 class="anchored" data-anchor-id="x-calibration">:x calibration</h2>
<p>Calibration is about aligning <em>stated</em> probabilities with empirical <em>frequencies</em>. DL models are often overconfident. When a model is well-calibrated it should do the following: if it predicts something with a 70% probability, the thing should happen 70% of the time. If someone tells me there’s a 30% rain probability in Edinburgh today, they I expect that there’s rain in 3 out of 10 times they tell me that.</p>
</section>
<section id="x-one-hot" class="level2">
<h2 class="anchored" data-anchor-id="x-one-hot">:x one-hot</h2>
<p>One-hot encoding transforms categorical variables into binary vectors where only one element is “hot” (1) and all others are “cold” (0). For DNA nucleotides: A → [1,0,0,0], T → [0,1,0,0], G → [0,0,1,0], C → [0,0,0,1]. This allows machine learning algorithms to process the data.</p>
</section>
<section id="x-bsl4" class="level2">
<h2 class="anchored" data-anchor-id="x-bsl4">:x bsl4</h2>
<p>BSL-4 labs have the strictest biosafety precautions, as they deal with agents that are aerosol-transmitted and/or highly dangerous and for which there is often no treatment or vaccine.</p>
</section>
<section id="x-synth" class="level2">
<h2 class="anchored" data-anchor-id="x-synth">:x synth</h2>
<p>A fully synthetic DNA molecule, often created from smaller components.</p>
</section>
<section id="x-embed" class="level2">
<h2 class="anchored" data-anchor-id="x-embed">:x-embed</h2>
<p>Any object - a word, DNA sequence, image, or even a lab - can be translated into a vector, i.e.&nbsp;an array of numbers. This is called and <strong>embedding</strong>. The dimensionality (100, 200, 1024) is usually chosen manually.</p>
<p>The idea is that these embedding vectors are trained so that similar objects are close together in embedding space, and dissimilar ones are farther apart. After training, the positions of these vectors encode rich, abstract properties of the original objects.</p>
<p>For example, in LLMs, the embedding of “King” - “Man” + “Women” ends up close to “Queen” - because the model has learned how sex and royalty are structured in language. In GEA, plasmid embeddings from the same lab will end up close together in embedding space, as they all share similar design signatures.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>